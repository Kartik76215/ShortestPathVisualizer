<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shortest Path Visualizer — WASM Edition</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="app">
    <aside class="panel">
      <div class="brand">
        <div class="logo">SP</div>
        <div>
          <h1>Shortest Path Visualizer</h1>
          <div class="muted">C++ & WebAssembly Edition</div>
        </div>
      </div>

      <p class="lead">Choose an algorithm, draw walls, drag start/end, and visualize the pathfinding process.</p>

      <label>Algorithm
        <select id="algorithm">
          <option value="astar">A* (Heuristic)</option>
          <option value="bfs">BFS (Breadth-first Search)</option>
          <option value="dijkstra">Dijkstra</option>
        </select>
      </label>

      <label>Speed (ms per step)
        <input id="speed" type="range" min="5" max="200" value="25">
      </label>

      <div class="modes">
        <div class="mode active" data-mode="draw">Draw Walls</div>
        <div class="mode" data-mode="move-start">Move Start</div>
        <div class="mode" data-mode="move-end">Move End</div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="runBtn" class="btn primary">Run</button>
        <button id="clearBtn" class="btn ghost">Clear</button>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="mazeBtn" class="btn ghost">Random Walls</button>
        <button id="resetBtn" class="btn ghost">Reset Grid</button>
      </div>

      <div class="legend" style="margin-top:12px">
        <div class="item"><div class="sw start"></div>Start</div>
        <div class="item"><div class="sw end"></div>End</div>
        <div class="item"><div class="sw" style="background:#2a1135"></div>Wall</div>
        <div class="item"><div class="sw" style="background:linear-gradient(90deg,#fff200,#ffcc00)"></div>Path</div>
      </div>

      <footer class="note">Tip: Click & drag to draw walls. Use modes to move start/end.</footer>
    </aside>

    <main class="stage panel">
      <div class="toolbar muted">
        Grid Visualization — Status: <span id="status">idle</span>
      </div>
      <div id="gridWrap" class="panel">
        <div id="grid"></div>
      </div>
    </main>
  </div>

  <script src="./pathfinder.js"></script>

  <script type="module">
    import { initWasm, findPath } from './wasm-bridge.js';

    const gridEl = document.getElementById('grid');
    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');
    const mazeBtn = document.getElementById('mazeBtn');
    const resetBtn = document.getElementById('resetBtn');
    const statusEl = document.getElementById('status');
    const algoSelect = document.getElementById('algorithm');
    const modeButtons = document.querySelectorAll('.mode');
    const speedInput = document.getElementById('speed');

    let currentMode = 'draw';
    let rows = 20, cols = 30;
    let grid = [], start = [5, 5], end = [12, 20];
    let isMouseDown = false;

    // === Mode Buttons ===
    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentMode = btn.dataset.mode;
      });
    });

    // === Build Grid ===
    function buildGrid() {
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
      grid = Array.from({ length: rows }, () => Array(cols).fill(0));
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;
          if (r === start[0] && c === start[1]) cell.classList.add('start');
          if (r === end[0] && c === end[1]) cell.classList.add('end');
          gridEl.appendChild(cell);
        }
      }
    }

    // === Mouse Handling ===
    gridEl.addEventListener('mousedown', e => {
      if (!e.target.classList.contains('cell')) return;
      const r = +e.target.dataset.r, c = +e.target.dataset.c;
      handleCellAction(r, c);
      isMouseDown = true;
    });
    gridEl.addEventListener('mouseover', e => {
      if (!isMouseDown || !e.target.classList.contains('cell')) return;
      const r = +e.target.dataset.r, c = +e.target.dataset.c;
      if (currentMode === 'draw') handleCellAction(r, c);
    });
    window.addEventListener('mouseup', () => isMouseDown = false);

    function handleCellAction(r, c) {
      const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      if (!cell) return;

      if (currentMode === 'draw') {
        if ((r === start[0] && c === start[1]) || (r === end[0] && c === end[1])) return;
        grid[r][c] = grid[r][c] ? 0 : 1;
        cell.classList.toggle('wall', !!grid[r][c]);
      } else if (currentMode === 'move-start') {
        const prev = document.querySelector('.cell.start');
        if (prev) prev.classList.remove('start');
        start = [r, c];
        cell.classList.add('start');
      } else if (currentMode === 'move-end') {
        const prev = document.querySelector('.cell.end');
        if (prev) prev.classList.remove('end');
        end = [r, c];
        cell.classList.add('end');
      }
    }

    // === Helpers ===
    function clearVisitedAndPath() {
      document.querySelectorAll('.cell.visited, .cell.path').forEach(c => {
        if (!c.classList.contains('start') && !c.classList.contains('end') && !c.classList.contains('wall'))
          c.classList.remove('visited', 'path');
      });
    }

    // === Random Walls ===
    mazeBtn.onclick = () => {
      clearVisitedAndPath();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
          const isSpecial = (r === start[0] && c === start[1]) || (r === end[0] && c === end[1]);
          const wall = !isSpecial && Math.random() < 0.25;
          grid[r][c] = wall ? 1 : 0;
          cell.classList.toggle('wall', wall);
        }
      }
    };

    resetBtn.onclick = () => { start = [5, 5]; end = [12, 20]; buildGrid(); };

    clearBtn.onclick = () => {
      document.querySelectorAll('.cell').forEach(c => {
        if (!c.classList.contains('start') && !c.classList.contains('end'))
          c.classList.remove('wall', 'visited', 'path');
      });
      grid = Array.from({ length: rows }, () => Array(cols).fill(0));
    };

    // === Animate Pathfinding ===
    async function animateSearch(visited, path, speed) {
      for (const [r, c] of visited) {
        const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
        if (!cell || cell.classList.contains('start') || cell.classList.contains('end') || cell.classList.contains('wall')) continue;
        cell.classList.add('visited');
        await new Promise(res => setTimeout(res, speed));
      }
      for (const [r, c] of path) {
        const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
        if (!cell || cell.classList.contains('start') || cell.classList.contains('end')) continue;
        cell.classList.remove('visited');
        cell.classList.add('path');
        await new Promise(res => setTimeout(res, speed * 1.2));
      }
    }

    // === Run Algorithm ===
    runBtn.onclick = async () => {
      clearVisitedAndPath();
      statusEl.textContent = "Running...";
      const wallString = grid.flat().map(v => (v ? '1' : '0')).join('');
      const algo = algoSelect.value;
      const speed = +speedInput.value;
      const wasm = await initWasm();
      const result = findPath(wasm, algo, start[0], start[1], end[0], end[1], wallString, rows, cols);
      const parsed = JSON.parse(result);
      const visited = parsed.visited || [];
      const path = parsed.path || [];
      await animateSearch(visited, path, speed);
      statusEl.textContent = path.length ? "Done!" : "No Path Found!";
    };

    buildGrid();
  </script>
</body>
</html>
