<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shortest Path Visualizer â€” WASM Edition</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="app">
    <aside class="panel">
      <div class="brand">
        <div class="logo">SP</div>
        <div>
          <h1>Shortest Path Visualizer</h1>
          <div class="muted">Powered by C++ & WebAssembly ðŸš€</div>
        </div>
      </div>

      <div class="controls">
        <label>Algorithm
          <select id="algorithm">
            <option value="astar">A* (Heuristic)</option>
            <option value="bfs">BFS (Breadth-First)</option>
            <option value="dijkstra">Dijkstra</option>
          </select>
        </label>

        <label>Speed (ms per step)
          <input id="speed" type="range" min="0" max="200" value="25">
        </label>

        <div class="row">
          <input id="rows" class="small-input" type="number" min="8" max="60" value="20">
          <input id="cols" class="small-input" type="number" min="8" max="60" value="30">
        </div>

        <div class="row" style="margin-top:8px;">
          <button id="runBtn" class="btn primary">Run</button>
          <button id="resetBtn" class="btn ghost">Reset Grid</button>
        </div>

        <div class="row" style="margin-top:8px;">
          <button id="drawWalls" class="btn ghost">Draw Walls</button>
          <button id="moveStart" class="btn ghost">Move Start</button>
          <button id="moveEnd" class="btn ghost">Move End</button>
        </div>

        <div class="row" style="margin-top:8px;">
          <button id="randomWalls" class="btn ghost">Random Walls</button>
        </div>

        <div class="legend" style="margin-top:10px">
          <div class="item"><div class="sw start"></div>Start</div>
          <div class="item"><div class="sw end"></div>End</div>
          <div class="item"><div class="sw wall"></div>Wall</div>
          <div class="item"><div class="sw path"></div>Path</div>
        </div>
      </div>
    </aside>

    <main class="stage">
      <div id="grid"></div>
    </main>
  </div>
  <script src="./pathfinder.js"></script>
  <script type="module">
    import { initWasm, findPath } from './wasm-bridge.js';

    const gridElem = document.getElementById("grid");
    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");
    const drawWallsBtn = document.getElementById("drawWalls");
    const moveStartBtn = document.getElementById("moveStart");
    const moveEndBtn = document.getElementById("moveEnd");
    const randomWallsBtn = document.getElementById("randomWalls");
    const rowsInput = document.getElementById("rows");
    const colsInput = document.getElementById("cols");

    let grid = [];
    let mode = "draw"; // draw, moveStart, moveEnd
    let rows = +rowsInput.value;
    let cols = +colsInput.value;
    let start = { r: 0, c: 0 };
    let end = { r: rows - 1, c: cols - 1 };
    let isMouseDown = false;

    function generateGrid() {
      gridElem.innerHTML = "";
      grid = Array.from({ length: rows }, (_, r) =>
        Array.from({ length: cols }, (_, c) => {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.r = r;
          cell.dataset.c = c;
          if (r === start.r && c === start.c) cell.classList.add("start");
          if (r === end.r && c === end.c) cell.classList.add("end");
          gridElem.appendChild(cell);
          return cell;
        })
      );
      gridElem.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
    }

    function resetGrid() {
      for (const row of grid) {
        for (const cell of row) {
          cell.className = "cell";
        }
      }
      grid[start.r][start.c].classList.add("start");
      grid[end.r][end.c].classList.add("end");
    }

    function randomWalls() {
      resetGrid();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (Math.random() < 0.25 && !(r === start.r && c === start.c) && !(r === end.r && c === end.c)) {
            grid[r][c].classList.add("wall");
          }
        }
      }
    }

    gridElem.addEventListener("mousedown", (e) => {
      if (!e.target.classList.contains("cell")) return;
      isMouseDown = true;
      const r = +e.target.dataset.r;
      const c = +e.target.dataset.c;

      if (mode === "draw") {
        e.target.classList.toggle("wall");
      } else if (mode === "moveStart") {
        grid[start.r][start.c].classList.remove("start");
        start = { r, c };
        e.target.classList.add("start");
      } else if (mode === "moveEnd") {
        grid[end.r][end.c].classList.remove("end");
        end = { r, c };
        e.target.classList.add("end");
      }
    });

    gridElem.addEventListener("mouseover", (e) => {
      if (!isMouseDown || !e.target.classList.contains("cell")) return;
      if (mode === "draw") e.target.classList.toggle("wall");
    });

    document.addEventListener("mouseup", () => (isMouseDown = false));

    drawWallsBtn.onclick = () => mode = "draw";
    moveStartBtn.onclick = () => mode = "moveStart";
    moveEndBtn.onclick = () => mode = "moveEnd";
    randomWallsBtn.onclick = randomWalls;
    resetBtn.onclick = resetGrid;

    runBtn.onclick = async () => {
      const wasm = await initWasm();
      const path = await findPath(start.r, start.c, end.r, end.c);
      try {
        const coords = JSON.parse(path);
        for (const cellStr of coords) {
          const [r, c] = cellStr.replace(/[()]/g, "").split(",").map(Number);
          if ((r === start.r && c === start.c) || (r === end.r && c === end.c)) continue;
          grid[r][c].classList.add("path");
          await new Promise(res => setTimeout(res, 30));
        }
      } catch (e) {
        console.error("Error visualizing path:", e);
      }
    };

    generateGrid();
    initWasm();
  </script>
</body>
</html>
